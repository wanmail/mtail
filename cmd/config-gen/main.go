package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"reflect"

	"github.com/segmentio/kafka-go"
)

const (
	KafkaConfig = "KafkaConfig"
)

var (
	configType   string
	targetFile   string
	targetModule string
)

func init() {
	flag.StringVar(&configType, "type", KafkaConfig, "The type of config to generate")
	flag.StringVar(&targetFile, "file", "config_generated.go", "The target file to generate the config from")
	flag.StringVar(&targetModule, "module", "main", "The target module name")
}

func main() {
	flag.Parse()

	var p interface{}

	b := new(bytes.Buffer)

	fmt.Fprintf(b, "// Code generated by github.com/wanmail/mtail/cmd/config-gen; DO NOT EDIT.\n")
	fmt.Fprintf(b, "package %s\n\n", targetModule)

	fmt.Fprintf(b, "import (\n")
	fmt.Fprintf(b, "	\"strings\"\n")
	fmt.Fprintf(b, "	\"time\"\n")
	fmt.Fprintf(b, "	\"strconv\"\n")
	fmt.Fprintf(b, "	\"net/url\"\n")
	fmt.Fprintf(b, "	\"github.com/segmentio/kafka-go\"\n")
	fmt.Fprintf(b, ")\n\n\n")

	switch configType {
	case KafkaConfig:
		p = kafka.ReaderConfig{}
		fmt.Fprintf(b, "func parse%s(u *url.URL, config *kafka.ReaderConfig) error {\n\n", configType)

	}

	v := reflect.ValueOf(p)
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		switch field.Type.Kind() {
		case reflect.String:
			fmt.Fprintf(b, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
			fmt.Fprintf(b, "		config.%s = %s\n", field.Name, field.Name)
			fmt.Fprintf(b, "	}\n\n")
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			fmt.Fprintf(b, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
			fmt.Fprintf(b, "		i, err := strconv.Atoi(%s)\n", field.Name)
			fmt.Fprintf(b, "		if err != nil {\n")
			fmt.Fprintf(b, "			return err\n")
			fmt.Fprintf(b, "		}\n")
			switch field.Type.String() {
			case "int":
				fmt.Fprintf(b, "		config.%s = i\n", field.Name)
			case "time.Duration":
				fmt.Fprintf(b, "		config.%s = time.Second * time.Duration(i)\n", field.Name)
			default:
				fmt.Fprintf(b, "		config.%s = %s(i)\n", field.Name, field.Type.String())
			}
			fmt.Fprintf(b, "	}\n\n")

		case reflect.Bool:
			fmt.Fprintf(b, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
			fmt.Fprintf(b, "		b, err := strconv.ParseBool(%s)\n", field.Name)
			fmt.Fprintf(b, "		if err != nil {\n")
			fmt.Fprintf(b, "			return err\n")
			fmt.Fprintf(b, "		}\n")
			fmt.Fprintf(b, "		config.%s = b\n", field.Name)
			fmt.Fprintf(b, "	}\n\n")

		case reflect.Slice:
			if field.Type.Elem().Kind() == reflect.String {
				fmt.Fprintf(b, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
				fmt.Fprintf(b, "		config.%s = strings.Split(%s, \",\")\n", field.Name, field.Name)
				fmt.Fprintf(b, "	}\n\n")
			}
		default:
			fmt.Fprintf(b, "  // %s is not supported\n\n", field.Name)

		}
	}

	fmt.Fprintf(b, "  return nil\n")
	fmt.Fprintf(b, "}\n")

	err := os.WriteFile(targetFile, b.Bytes(), 0644)
	if err != nil {
		fmt.Println("Failed to write file:", err)
		os.Exit(1)
	}
}
