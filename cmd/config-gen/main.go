package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"reflect"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/segmentio/kafka-go"
)

const (
	KafkaConfig = "KafkaConfig"
	S3Config    = "S3Config"
)

var (
	configType   string
	targetFile   string
	targetModule string
)

func init() {
	flag.StringVar(&configType, "type", KafkaConfig, "The type of config to generate")
	flag.StringVar(&targetFile, "file", "config_generated.go", "The target file to generate the config from")
	flag.StringVar(&targetModule, "module", "main", "The target module name")
}

func main() {
	flag.Parse()

	ims := make(map[string]bool)

	ims["net/url"] = true

	var p interface{}

	// file header buffer
	hb := new(bytes.Buffer)

	// function buffer
	fb := new(bytes.Buffer)

	fmt.Fprintf(hb, "// Code generated by github.com/wanmail/mtail/cmd/config-gen; DO NOT EDIT.\n")
	fmt.Fprintf(hb, "package %s\n\n", targetModule)

	switch configType {
	case KafkaConfig:
		ims["github.com/segmentio/kafka-go"] = true
		p = kafka.ReaderConfig{}
		fmt.Fprintf(fb, "func parse%s(u *url.URL, config *kafka.ReaderConfig) error {\n\n", configType)
	case S3Config:
		ims["github.com/aws/aws-sdk-go-v2/aws"] = true
		p = aws.Config{}
		fmt.Fprintf(fb, "func parse%s(u *url.URL, config *aws.Config) error {\n\n", configType)
	}

	v := reflect.ValueOf(p)
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		switch field.Type.Kind() {
		case reflect.String:
			switch field.Type.String() {
			case "string":
				fmt.Fprintf(fb, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
				fmt.Fprintf(fb, "		config.%s = %s\n", field.Name, field.Name)
				fmt.Fprintf(fb, "	}\n\n")
			default:
				fmt.Fprintf(fb, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
				fmt.Fprintf(fb, "		config.%s = %s(%s)\n", field.Name, field.Type.String(), field.Name)
				fmt.Fprintf(fb, "	}\n\n")
			}

		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			ims["strconv"] = true
			fmt.Fprintf(fb, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
			fmt.Fprintf(fb, "		i, err := strconv.Atoi(%s)\n", field.Name)
			fmt.Fprintf(fb, "		if err != nil {\n")
			fmt.Fprintf(fb, "			return err\n")
			fmt.Fprintf(fb, "		}\n")
			switch field.Type.String() {
			case "int":
				fmt.Fprintf(fb, "		config.%s = i\n", field.Name)
			case "time.Duration":
				ims["time"] = true
				fmt.Fprintf(fb, "		config.%s = time.Second * time.Duration(i)\n", field.Name)
			default:
				fmt.Fprintf(fb, "		config.%s = %s(i)\n", field.Name, field.Type.String())
			}
			fmt.Fprintf(fb, "	}\n\n")

		case reflect.Bool:
			fmt.Fprintf(fb, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
			fmt.Fprintf(fb, "		b, err := strconv.ParseBool(%s)\n", field.Name)
			fmt.Fprintf(fb, "		if err != nil {\n")
			fmt.Fprintf(fb, "			return err\n")
			fmt.Fprintf(fb, "		}\n")
			fmt.Fprintf(fb, "		config.%s = b\n", field.Name)
			fmt.Fprintf(fb, "	}\n\n")

		case reflect.Slice:
			if field.Type.Elem().Kind() == reflect.String {
				ims["strings"] = true
				fmt.Fprintf(fb, "	if %s := u.Query().Get(\"%s\"); %s != \"\" {\n", field.Name, field.Name, field.Name)
				fmt.Fprintf(fb, "		config.%s = strings.Split(%s, \",\")\n", field.Name, field.Name)
				fmt.Fprintf(fb, "	}\n\n")
			}
		default:
			fmt.Fprintf(fb, "  // %s is not supported\n\n", field.Name)

		}
	}

	fmt.Fprintf(hb, "import (\n")
	for im := range ims {
		fmt.Fprintf(hb, "	\"%s\"\n", im)
	}
	fmt.Fprintf(hb, ")\n\n")

	fmt.Fprintf(fb, "  return nil\n")
	fmt.Fprintf(fb, "}\n")

	hb.Write(fb.Bytes())

	err := os.WriteFile(targetFile, hb.Bytes(), 0644)
	if err != nil {
		fmt.Println("Failed to write file:", err)
		os.Exit(1)
	}
}
